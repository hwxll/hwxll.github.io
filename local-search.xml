<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为命令行 Git 启用代理</title>
    <link href="/2025/01/21/shell_git_proxy/"/>
    <url>/2025/01/21/shell_git_proxy/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a><span class="label label-primary">1 问题描述</span></h2><p>在 Mac 上使用 ClashX 进行科学上网时，浏览器能够正常访问 GitHub，但在命令行使用 Git 命令时经常无法连接。通过 <code>GIT_TRACE=1 GIT_TRACE_PACKET=1 GIT_TRACE_CURL=1 git fetch</code> 进行调试，发现 Git 并没有使用代理，而是直接访问 GitHub 服务器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">Hw-MacBook-Pro:images hw$ GIT_TRACE=1 GIT_TRACE_PACKET=1 GIT_TRACE_CURL=1 git fetch<br>13:05:29.021638 exec-cmd.c:139          trace: resolved executable path from Darwin stack: /Applications/Xcode.app/Contents/Developer/usr/bin/git<br>...<br>13:05:29.151861 http.c:756              == Info: Connected to github.com (20.205.243.166) port 443<br></code></pre></td></tr></table></figure><p>从输出中可以看出，Git 并没有使用代理。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a><span class="label label-success">2 解决方案</span></h2><p>根据 StackExchange 文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Why git, curl and such tools can't use system network proxy?](https://unix.stackexchange.com/questions/655764/why-git-curl-and-such-tools-cant-use-system-network-proxy)">[1]</span></a></sup> 的提示：</p><p class="note note-info"> For command line tools like curl etc. "system proxy settings" is exactly what you have set in your second example - that is, the variables `$http_proxy` etc. Does the GUI tool you use for setting "system proxy settings" set these variables for terminal sessions? If not, then you have the answer why the settings are not used. Simply your GUI proxy setting application is incompatible with command line tools.</p><p>命令行 Git 需要配置环境变量 <code>$http_proxy</code> 和 <code>$https_proxy</code>。</p><p>我的 ClashX 在 <code>127.0.0.1:7890</code> 端口开启了 HTTP、HTTPS 和 SOCKS5 代理服务。</p><p>通过以下命令为 Git 配置代理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global http.proxy http://127.0.0.1:7890<br>git config --global https.proxy http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p>配置完成后，再次执行 <code>git fetch</code>，可以看到 Git 现在走了代理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">Hw-MacBook-Pro:images hw$ GIT_TRACE=1 GIT_TRACE_PACKET=1 GIT_TRACE_CURL=1 git fetch<br>13:06:29.140435 exec-cmd.c:139          trace: resolved executable path from Darwin stack: /Applications/Xcode.app/Contents/Developer/usr/bin/git<br>...<br>13:06:29.211802 http.c:756              == Info: Connected to 127.0.0.1 (127.0.0.1) port 7890<br>...<br>13:06:29.211903 http.c:756              == Info: Establish HTTP proxy tunnel to github.com:443<br></code></pre></td></tr></table></figure><h2 id="3-在-Ubuntu-虚拟机上的配置"><a href="#3-在-Ubuntu-虚拟机上的配置" class="headerlink" title="3 在 Ubuntu 虚拟机上的配置"></a><span class="label label-warning">3 在 Ubuntu 虚拟机上的配置</span></h2><p>虚拟机与宿主机通过桥接模式连接，虚拟机的 IP 地址为 <code>10.211.55.18</code>，宿主机的 IP 为 <code>10.211.55.2</code>。为虚拟机上的 Git 配置代理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global http.proxy http://10.211.55.2:7890<br>git config --global https.proxy http://10.211.55.2:7890<br></code></pre></td></tr></table></figure><p>同时，确保 ClashX 设置为允许局域网连接。</p><p>在虚拟机中执行 Git 命令并确认代理设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">hw@hw-Parallels-Virtual-Platform:~/images$ GIT_TRACE=1 GIT_TRACE_PACKET=1 GIT_TRACE_CURL=1 git fetch<br>13:07:29.255333 git.c:463               trace: built-in: git fetch<br>...<br>13:07:29.281054 http.c:845              == Info: Connected to 10.211.55.2 (10.211.55.2) port 7890<br>...<br>13:07:29.281179 http.c:845              == Info: Establish HTTP proxy tunnel to github.com:443<br></code></pre></td></tr></table></figure><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4 参考文章"></a><span class="label label-info">4 参考文章</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://unix.stackexchange.com/questions/655764/why-git-curl-and-such-tools-cant-use-system-network-proxy">Why git, curl and such tools can’t use system network proxy?</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Version Control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>ClashX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组三分</title>
    <link href="/2024/04/11/partition/"/>
    <url>/2024/04/11/partition/</url>
    
    <content type="html"><![CDATA[<h2 id="1-相关问题描述"><a href="#1-相关问题描述" class="headerlink" title="1 相关问题描述"></a><span class="label label-info">1 相关问题描述</span></h2><h3 id="1-1-荷兰国旗问题-1"><a href="#1-1-荷兰国旗问题-1" class="headerlink" title="1.1 荷兰国旗问题[1]"></a><span class="label label-info">1.1 荷兰国旗问题<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 75. 颜色分类](https://leetcode.cn/problems/sort-colors/description/)">[1]</span></a></sup></span></h3><p>荷兰国旗问题是一个经典的计算机科学问题，其来源于荷兰国旗的三色（红、白、蓝）设计，要求通过一次遍历将包含三种颜色的数组按颜色进行排序。数组中的每个元素代表一种颜色，分别用 0、1 和 2 表示红色、白色和蓝色。目标是将这个数组重新排列，使得所有的 0 都位于数组的前面，所有的 1 都位于中间，所有的 2 都位于数组的后面。</p><h3 id="1-2-三路快速排序"><a href="#1-2-三路快速排序" class="headerlink" title="1.2 三路快速排序"></a><span class="label label-info">1.2 三路快速排序</span></h3><p>三路快速排序（3-way QuickSort）是快速排序算法的一种变体，特别适合处理有大量重复元素的数组。在标准快速排序中，我们选择一个元素作为基准（pivot），然后将数组分为两部分：小于基准的元素和大于基准的元素。而在三路快速排序中，数组被分为三个部分：小于基准的元素、等于基准的元素和大于基准的元素。这样，每次递归时，等于基准的元素已经被正确排序，因此下一次递归只需要处理小于和大于基准的两个子数组。</p><p>三路快速排序的主要优点是它能够减少对重复元素的无谓比较，从而提高排序的效率。特别是当数组中存在大量重复元素时，与传统的快速排序相比，三路快速排序可以显著减少递归的深度，提高排序速度。</p><h3 id="1-3-三路快速选择"><a href="#1-3-三路快速选择" class="headerlink" title="1.3 三路快速选择"></a><span class="label label-info">1.3 三路快速选择</span></h3><p>快速选择算法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[维基百科：快速选择算法](https://en.wikipedia.org/wiki/Quickselect)">[2]</span></a></sup>是一种高效地找到数组中第 <em>k</em> 小或第 <em>k</em> 大元素的方法，它是快速排序的一个变种。它通过选择一个基准元素（pivot），把数组分为小于和大于基准的两部分来工作。与快速排序不同，快速选择只对含有第 <em>k</em> 小元素的子数组进行递归，减少了计算量。</p><p>三路快速选择是快速选择的扩展，适用于含有大量重复元素的数组。它按小于、等于、大于基准元素的三部分来分数组，并能在寻找第 <em>k</em> 小或大元素时跳过重复项。这种方法有效减少了重复元素的比较次数，提升了效率。</p><p>三路快速选择在处理重复元素多的数组时更加高效，减少了不必要的比较和递归深度，提高了性能。</p><p>例如 LeetCode 215. 数组中的第K个最大元素<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)">[3]</span></a></sup> 中，有一个测试用例为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] + [<span class="hljs-number">1</span>] * <span class="hljs-number">99000</span> + [-<span class="hljs-number">5</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>]<br>k = <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p> 如果使用普通的快速选择算法，极易发生栈溢出。</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a><span class="label label-warning">2 代码实现</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], pivot:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    在一次遍历中将列表 nums 中小于、等于、大于 pivot 的元素</span><br><span class="hljs-string">    分别移动到列表的左侧、中间、右侧，使用三指针的方法。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># i 用于遍历 nums 中的每个元素</span><br>    <span class="hljs-comment"># left 指向当前未处理的最左侧元素的位置，用于放置小于 pivot 的元素</span><br>    <span class="hljs-comment"># right 指向当前未处理的最右侧元素的位置，用于放置大于 pivot 的元素</span><br>    i, left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span> i &lt;= right:<br>        <span class="hljs-keyword">if</span> nums[i] &lt; pivot:<br>            <span class="hljs-comment"># 如果当前元素小于 pivot，则将其与 left 指针所指元素交换</span><br>            <span class="hljs-comment"># 交换后，left 和 i 都向右移动一位</span><br>            nums[i], nums[left] = nums[left], nums[i]<br>            left += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> nums[i] &gt; pivot:<br>            <span class="hljs-comment"># 如果当前元素大于 pivot，则将其与 right 指针所指元素交换</span><br>            <span class="hljs-comment"># 交换后，right 向左移动一位，而 i 不变，因为交换后的新元素还未被比较</span><br>            nums[i], nums[right] = nums[right], nums[i]<br>            right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前元素等于 pivot，则不需要交换</span><br>            <span class="hljs-comment"># i 向右移动一位，继续遍历</span><br>            i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>首先理解一下各个区域的含义</p><img src="partition.png"><p>当 <code>nums[i] &lt; pivot</code> 时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> nums[i] &lt; pivot:<br>    <span class="hljs-comment"># 如果当前元素小于 pivot，则将其与 left 指针所指元素交换</span><br>    <span class="hljs-comment"># 交换后，left 和 i 都向右移动一位</span><br>    nums[i], nums[left] = nums[left], nums[i]<br>    left += <span class="hljs-number">1</span><br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><img src="small.png"><p>当 <code>nums[i] = pivot</code> 时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 如果当前元素等于 pivot，则不需要交换</span><br>    <span class="hljs-comment"># i 向右移动一位，继续遍历</span><br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><img src="equal.png"><p>当 <code>nums[i] &gt; pivot</code> 时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> nums[i] &gt; pivot:<br>    <span class="hljs-comment"># 如果当前元素大于 pivot，则将其与 right 指针所指元素交换</span><br>    <span class="hljs-comment"># 交换后，right 向左移动一位，而 i 不变，因为交换后的新元素还未被比较</span><br>    nums[i], nums[right] = nums[right], nums[i]<br>    right -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><img src="big.png" alt="big"><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a><span class="label label-success">3 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/sort-colors/description/">LeetCode 75. 颜色分类</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Quickselect">维基百科：快速选择算法</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">LeetCode 215. 数组中的第K个最大元素</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Sort</category>
      
      <category>Quick Sort</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的中序遍历</title>
    <link href="/2024/02/27/inorder/"/>
    <url>/2024/02/27/inorder/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)">[1]</span></a></sup></span></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><img src="/2024/02/27/inorder/inorder_1.jpg" class=""><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p> <strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p class="note note-info">相关问题：<br/>&nbsp;&nbsp;&nbsp;&nbsp;二叉树的前序遍历<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)">[2]</span></a></sup> <br/>&nbsp;&nbsp;&nbsp;&nbsp;二叉树的后序遍历<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)">[3]</span></a></sup> </p><h2 id="2-Solution-Recursion"><a href="#2-Solution-Recursion" class="headerlink" title="2 Solution: Recursion"></a><span class="label label-success">2 Solution: Recursion</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个辅助递归方法来进行中序遍历</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraverse</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 确保当前节点不为空</span><br>        inorderTraverse(root.left, res); <span class="hljs-comment">// 首先递归遍历左子树</span><br>        res.add(root.val); <span class="hljs-comment">// 访问当前节点，将其值添加到结果列表中</span><br>        inorderTraverse(root.right, res); <span class="hljs-comment">// 最后递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主方法，调用辅助方法以实现二叉树的中序遍历</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 初始化存储遍历结果的列表</span><br>    inorderTraverse(root, res); <span class="hljs-comment">// 使用辅助方法开始递归遍历</span><br><br>    <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回遍历结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Solution-Stack-based-Iteration"><a href="#3-Solution-Stack-based-Iteration" class="headerlink" title="3 Solution: Stack-based Iteration"></a><span class="label label-warning">3 Solution: Stack-based Iteration</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 使用Deque而不是Stack类以提高性能</span><br>    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br><br>    <span class="hljs-comment">// 继续遍历直到当前节点为空且栈为空</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-comment">// 遍历到最左边的节点，并沿途将所有节点压入栈</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current); <span class="hljs-comment">// 将当前节点压入栈</span><br>            current = current.left; <span class="hljs-comment">// 移动到左子节点</span><br>        &#125;<br><br>        <span class="hljs-comment">// 弹出栈顶元素，即最左侧的节点</span><br>        current = stack.pop();<br>        res.add(current.val); <span class="hljs-comment">// 访问节点</span><br><br>        <span class="hljs-comment">// 转向右子树进行相同的过程</span><br>        current = current.right;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-迭代过程分析"><a href="#3-1-迭代过程分析" class="headerlink" title="3.1 迭代过程分析"></a><span class="label label-warning">3.1 迭代过程分析</span></h3><p>假设我们要遍历下面这棵树，最开始 <span class="label label-danger">current</span> 指向 <code>1</code> ，表示我们想要中序遍历以 <code>1</code> 为根节点的这棵树</p><img src="tree0.png"><p>根据中序遍历的规则：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[ <span class="hljs-comment">[左子树的中序遍历结果]</span>, 根节点, <span class="hljs-comment">[右子树的中序遍历结果]</span> ]</span><br></code></pre></td></tr></table></figure><p>要想中序遍历 <code>1</code> 这棵树</p><ol><li>需要先中序遍历完 <code>1</code> 的左子树 <code>2</code> </li><li>然后才能遍历节点 <code>1</code> </li><li>最后对  <code>1</code> 的右子树  <code>3</code> 进行中序遍历</li></ol><p>所以我们首先将 <span class="label label-danger">current</span> <code>1</code> 节点压栈，然后更新 <span class="label label-danger">current</span> 指向 <span class="label label-danger">current.left</span> <code>2</code> 表示首先对 <code>1</code> 的左子树 <code>2</code> 进行中序遍历</p><p class="note note-success">为什么要将 <span class="label label-danger">current</span> 节点压栈？<br/>保存访问路径，实现回溯</p><img src="tree1.png" alt="tree1" width="50%" height="50%"><p>同理，若要对以 <code>2</code> 为根节点的树进行中序遍历，则需要先对 <code>2</code> 的左子树 <code>4</code> 进行中序遍历，同时将节点 <code>2</code> 压栈</p><img src="tree2.png" alt="tree2" width="50%" height="50%"><p>同理，若要对以 <code>4</code> 为根节点的树进行中序遍历，则需要先对 <code>4</code> 的左子树 <code>null</code> 进行中序遍历，同时将节点 <code>4</code> 压栈</p><img src="tree3.png"><p>上面的过程对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历到最左边的节点，并沿途将所有节点压入栈</span><br><span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>    stack.push(current); <span class="hljs-comment">// 将当前节点压入栈</span><br>    current = current.left; <span class="hljs-comment">// 移动到左子节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在以  <code>4</code> 为根节点的树的左子树 <code>null</code> 已经遍历完成，对节点 <code>4</code> 进行遍历（出栈），然后对 <code>4</code> 的右子树 <code>7</code> 进行中序遍历</p><img src="tree4.png" alt="tree4" width="50%" height="50%"><p>这里的过程对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 弹出栈顶元素，即最左侧的节点</span><br>current = stack.pop();<br>res.add(current.val); <span class="hljs-comment">// 访问节点</span><br><br><span class="hljs-comment">// 转向右子树进行相同的过程</span><br>current = current.right;<br></code></pre></td></tr></table></figure><p>将节点 <code>7</code> 入栈，对 <code>7</code> 的左子树进行遍历</p><img src="tree5.png"><p>遍历节点 <code>7</code> (出栈)，遍历节点 <code>7</code> 的右子树 <code>null</code></p><img src="tree6.png"><p>现在栈顶元素 <code>2</code> 的左子树部分已经遍历完成，对节点 <code>2</code> 进行遍历（出栈），然后对 <code>2</code> 的右子树 <code>null</code> 进行中序遍历</p><img src="tree7.png"><p>现在栈顶元素 <code>1</code> 的左子树部分已经遍历完成，对节点 <code>1</code> 进行遍历（出栈），然后对 <code>1</code> 的右子树 <code>3</code> 进行中序遍历</p><img src="tree8.png" alt="tree8" width="50%" height="50%"><p>后面的过程如下：</p><p>对 <code>3</code> 的左子树 <code>5</code> 进行遍历，<code>5</code> 遍历结束后遍历节点 <code>3</code>（出栈），然后遍历 <code>3</code> 的右子树 <code>6</code> </p><img src="tree9.png" /><img src="tree10.png" /><p>对以 <code>6</code> 为根节点的树中序遍历过程跟树 <code>5</code> 相同：先遍历 <code>6</code> 的左子树 <code>null</code> ,遍历节点 <code>6</code>, 遍历 <code>6</code> 的右子树 <code>null</code>，最终整棵树遍历完成。</p><img src="tree11.png" /><p/><p class="note note-warning">  上面的过程实际上是模拟了递归时对栈的使用过程。</p><h3 id="3-2-代码细节思考"><a href="#3-2-代码细节思考" class="headerlink" title="3.2 代码细节思考 "></a><span class="label label-warning">3.2 代码细节思考 </span></h3><p><strong>为什么不直接使用 Stack 类而是使用 Deque ？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br>Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>自Java 1.6起，<code>Stack</code>类被认为是遗留类，其使用在新的代码中不再推荐。Java平台库提供了<code>Deque</code>接口（双端队列），并推荐使用实现了<code>Deque</code>接口的<code>ArrayDeque</code>类作为栈的实现。<code>ArrayDeque</code>比<code>Stack</code>类有更好的性能。</p><img src="not_Stack.png" /><h2 id="4-Solution-Morris-Traversal"><a href="#4-Solution-Morris-Traversal" class="headerlink" title="4 Solution: Morris Traversal"></a><span class="label label-danger">4 Solution: Morris Traversal</span></h2><p class="note note-secondary">    KMP算法<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[字符串匹配之 KMP 算法](https://hwxll.github.io/2024/02/05/kmp/)">[4]</span></a></sup>（Knuth-Morris-Pratt字符串搜索算法）是由三位计算机科学家共同发明的，他们是：<br>  &bull; <strong>Donald Knuth（唐纳德·克努特）</strong>：美国计算机科学家，著有《计算机程序设计艺术》（The Art of Computer Programming）等多部经典计算机科学著作；<br>  &bull; <strong>Vaughan Pratt（沃恩·普拉特）</strong>：美国计算机科学家，斯坦福大学教授，对计算理论、特别是自动机理论和并发理论有重大贡献；<br>  &bull; <strong>James H. Morris（詹姆斯·H·莫里斯）</strong>：美国计算机科学家，曾在多家知名技术公司和大学任职，对计算机科学的多个领域有贡献。<br><br>  这里的Morris便是上面的 James H. Morris（詹姆斯·H·莫里斯）。</p><h3 id="4-1-算法介绍"><a href="#4-1-算法介绍" class="headerlink" title="4.1 算法介绍"></a><span class="label label-danger">4.1 算法介绍</span></h3><p>Morris遍历算法能够在不使用栈或递归的情况下，以O(1)的空间复杂度和O(n)的时间复杂度遍历二叉树（n是树中节点的数量）。</p><p>Morris遍历的精妙之处在于利用了二叉树中大量的空闲指针（即那些原本指向NULL的右子指针），通过建立和断开这些临时链接，实现了对树的高效遍历，同时避免了对额外存储空间的需求。</p><p>以下是中序遍历的核心思想：</p><ol><li><p><strong>当前节点设置为根节点</strong>：开始时，将当前节点设置为树的根节点。</p></li><li><p><strong>左子树处理</strong>：</p><ul><li>如果当前节点的左子树存在，找到当前节点的前驱节点。</li><li>如果前驱节点的右子节点为空（即，还没有建立临时链接回当前节点），则将前驱节点的右子节点设置为当前节点，并将当前节点更新为其左子节点。</li><li>如果前驱节点的右子节点已经指向当前节点（表明已经处理过左子树），则将前驱节点的右子节点重新设为空（恢复树的原状），并输出当前节点（因为此时左子树已经遍历完成），然后将当前节点更新为其右子节点。</li></ul><p class="note note-primary">  "前驱节点" 指的就是在中序遍历顺序下，当前节点之前被访问的那个节点。对于任何一个节点，如果你从这个节点出发，向左走一步，然后尽可能地向右走，最后到达的节点就是它的前驱节点。这个“最后到达”的节点，我们称之为最右节点/前驱节点，因为你不能再往右走了。</p></li><li><p><strong>右子树处理</strong>：</p><ul><li>如果当前节点没有左子树，则输出当前节点，并将当前节点更新为其右子节点。</li></ul></li><li><p><strong>重复上述步骤</strong>，直到当前节点为空。</p></li></ol><p class="note note-danger">  Morris遍历算法最初是为二叉树的中序遍历设计的，因其能够在O(1)的空间复杂度下完成遍历，也可轻易修改以支持前序遍历。关于二叉树的后序遍历，Morris遍历的原理同样可以应用，但实现起来要复杂得多，因为后序遍历要求在访问节点的左右子树之后才访问该节点本身，这需要更复杂的回溯机制。</p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a><span class="label label-danger">4.2 代码实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>  <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (current.left == <span class="hljs-literal">null</span>) &#123;<br>            result.add(current.val);<br>            current = current.right; <span class="hljs-comment">// 移至右子树</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 找到前驱节点</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> current.left;<br>            <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-literal">null</span> &amp;&amp; pre.right != current) &#123;<br>                pre = pre.right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (pre.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 建立临时路径</span><br>                pre.right = current;<br>                current = current.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 恢复树的原状，并访问当前节点</span><br>                pre.right = <span class="hljs-literal">null</span>;<br>                result.add(current.val);<br>                current = current.right;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-过程分析"><a href="#4-3-过程分析" class="headerlink" title="4.3 过程分析"></a><span class="label label-danger">4.3 过程分析</span></h3><p>同样以上面的树为例，遍历过程如下：</p><p><span class="label label-danger">current</span> 指向 <code>1</code> , <code>1</code> 存在左子树，找到 <code>1</code> 的 前驱节点 <span class="label label-success">pre</span> ，将 <span class="label label-success">pre</span> 的右儿子指向 <code>1</code> (建立临时链接)</p><img src="morris0.png" alt="morris0" width="50%" height="50%"><p>更新 <span class="label label-danger">current</span> 为 <span class="label label-danger">current.left</span> ,  <span class="label label-danger">current</span> 指向 <code>2</code> ,  <code>2</code> 存在左子树，找到 <code>2</code> 的 前驱节点<span class="label label-success">pre</span>，将 <span class="label label-success">pre</span> 的右儿子指向 <code>2</code> (建立临时链接)</p><img src="morris1.png" alt="morris1" width="50%" height="50%"><p>更新 <span class="label label-danger">current</span> 为 <span class="label label-danger">current.left</span>,  <span class="label label-danger">current</span> 指向 <code>4</code> ，<code>4</code> 没有左儿子，将 <code>4</code> 加入到结果列表中，将 <span class="label label-danger">current</span> 指向 <code>4</code> 的右儿子</p><img src="morris2.png"> <p><span class="label label-danger">current</span> 指向 <code>7</code> , <code>7</code> 没有左儿子，将 <code>7</code> 加入到结果列表，将 <span class="label label-danger">current</span> 指向 <code>7</code> 的右儿子（从前面可知，<code>7</code> 是 <code>2</code> 的前驱节点，在这里 <code>7</code> 被遍历，下一个要被遍历的便是 <code>2</code>）</p><img src="morris3.png" alt="morris3" width="50%" height="50%"><p> <span class="label label-danger">current</span> 指向 <code>2</code> ,  <code>2</code> 存在左子树，找到 <code>2</code> 的 前驱节点 <span class="label label-success">pre</span> ，<span class="label label-success">pre.right</span> 不为 <code>null</code> (或者说指向了 <span class="label label-danger">current</span> )，恢复树的原状（删除临时链接），遍历当前节点（因为此时 <code>2</code> 左子树已经遍历完成），并更新 <span class="label label-danger">current</span> 为 <span class="label label-danger">current.right</span></p><img src="morris4.png"><p><span class="label label-danger">current</span> 指向 <code>1</code> , <code>1</code> 存在左子树，找到 <code>1</code> 的 前驱节点 <span class="label label-success">pre</span> ，<span class="label label-success">pre.right</span> 不为 <code>null</code> (或者说指向了 <span class="label label-danger">current</span> )，恢复树的原状（删除临时链接），遍历当前节点（因为此时 <code>1</code> 左子树已经遍历完成），并更新 <span class="label label-danger">current</span> 为 <span class="label label-danger">current.right</span></p><img src="morris5.png"><p><span class="label label-danger">current</span> 指向 <code>3</code> , <code>3</code> 存在左子树，找到 <code>3</code> 的 前驱节点 <span class="label label-success">pre</span> ，将 <span class="label label-success">pre</span> 的右儿子指向 <code>3</code> (建立临时链接)</p><img src="morris6.png" alt="morris6" width="50%" height="50%"><p>更新 <span class="label label-danger">current</span> 为 <span class="label label-danger">current.left</span>， <span class="label label-danger">current</span> 指向 <code>5</code> ，<code>5</code> 没有左儿子，将 <code>5</code> 加入到结果列表中，将 <span class="label label-danger">current</span> 指向 <code>5</code> 的右儿子</p><img src="morris7.png"><p><span class="label label-danger">current</span> 指向 <code>3</code> , <code>3</code> 存在左子树，找到 <code>3</code> 的 前驱节点 <span class="label label-success">pre</span> ，<span class="label label-success">pre.right</span> 不为 <code>null</code> (或者说指向了 <span class="label label-danger">current</span> )，恢复树的原状（删除临时链接），遍历当前节点（因为此时 <code>3</code> 左子树已经遍历完成），并更新 <span class="label label-danger">current</span> 为 <span class="label label-danger">current.right</span></p><img src="morris8.png"><p><span class="label label-danger">current</span> 指向 <code>6</code> , <code>6</code> 没有左儿子，将 <code>6</code> 加入到结果列表，将 <span class="label label-danger">current</span> 指向 <code>6</code> 的右儿子 <code>null</code> , 循环结束。</p><img src="morris9.png" alt="morris9" width="50%" height="50%"></p><p><span class="label label-danger"><strong>思考</strong></span></p><ol><li><span class="label label-danger">current</span> 节点的遍历过程与上面的 Stack-based Iteration 方案相同吗？</li></ol><p class="note note-info">相同，都是从根节点开始，沿着左子节点一直往下走，直到到达最左侧的节点，当到达最左侧节点后，转向访问该节点的右子树。唯一区别是 Stack-based Iteration 方案中会遍历 null 节点，而该方案不会。<br><br>  在不考虑null节点的情况下，current的遍历路径是：[<span class="label label-warning">1</span>, <span class="label label-warning">2</span>, <span class="label label-warning" style="text-decoration: underline;">4</span>, <span class="label label-success" style="text-decoration: underline;">7</span>, <span class="label label-primary" style="text-decoration: underline;">2</span>, <span class="label label-primary" style="text-decoration: underline;">1</span>, <span class="label label-success">3</span>, <span class="label label-warning" style="text-decoration: underline;">5</span>, <span class="label label-primary" style="text-decoration: underline;">3</span>, <span class="label label-success" style="text-decoration: underline;">6</span>]<br>  &bull;<span class="label label-warning"> </span>表示一路向左到达的节点。<br>  &bull;<span class="label label-success"> </span>表示转向右子树到达的节点。<br>  &bull;<span class="label label-primary"> </span>表示通过回溯到达的节点。<br>  &bull; <span style="text-decoration: underline;">&nbsp;&nbsp;</span> 表示加入结果列表的节点。</p><ol start="2"><li>建立临时链接的目的是什么？</li></ol><p class="note note-success">    用于回溯，在不同的遍历方案中，回溯的实现方式各不相同：<br>    &bull; 在<strong>递归方案</strong>中，利用函数调用栈来回溯。<br>    &bull; 在<strong>基于栈的迭代方案</strong>中，使用显式栈来回溯。<br>    &bull; 在本方案中，通过建立<strong>临时链接</strong>进行回溯。<br><br>    比如当节点 7 被遍历后，我们是通过先前创建的临时链接回溯到节点 2 继续遍历的。</p><h3 id="4-4-时间复杂度分析"><a href="#4-4-时间复杂度分析" class="headerlink" title="4.4 时间复杂度分析"></a><span class="label label-danger">4.4 时间复杂度分析</span></h3><p>在上述代码中，时间复杂度的主要部分来源于两个核心操作：遍历节点（通过 <span class="label label-danger">current</span> ）和寻找所有节点的前驱节点（ <span class="label label-success">pre</span> ）。</p><ol><li><p><strong>对 <span class="label label-danger">current</span> 的操作时间复杂度</strong>：</p><p>每个节点通过 <span class="label label-danger">current</span> 最多被访问两次，一次是向下访问到最左侧节点，另一次是通过建立的临时链接回溯。因此，对 <span class="label label-danger">current</span> 的操作的时间复杂度为O(n)。</p><blockquote><p>需要回溯的节点会被访问两次，例如节点 <code>2</code> ，不需要回溯节点仅被访问一次，例如节点 <code>4</code></p></blockquote></li><li><p><strong>寻找所有节点的前驱节点 <span class="label label-success">pre</span> </strong>：</p><p>寻找单个节点的前驱节点时间复杂度是和树的高度相关的，为O(log n)，所以直觉上整个算法过程中对所有节点的前驱节点的查找整体时间复杂度为O(n * log n)，但是实际上这个过程的时间复杂度也为O(n)。</p><p>以下面这棵树为例：</p><img src="morris_time_complexity.png" alt="morris_time_complexity" width="50%" height="50%"><p>在一棵二叉树中，任一节点的前驱节点可以这样查找：从当前节点出发，先向左走一步，随后一直向右走直到尽头，所到达的节点便是其前驱节点。</p><p>以节点 <code>0</code> 为例，其查找过程是：先左移到节点 <code>1</code>，再持续向右行进，依次通过节点 <code>4</code>、<code>8</code>、<code>12</code>、<code>16</code>，将路径上的边进行标注（标注为0，表明是节点 <code>0</code> 的前驱节点查找路径）。对其他节点也采用同样的方法，并进行了相应的边标注。</p><p>树中每条左连线恰好被遍历一次：对于任意一条连接父节点 <code>a</code> 和子节点 <code>b</code> 的左连线，只有在寻找 <code>a</code> 的前驱节点时才会通过这条连线。</p><p>至于右连线，它们被遍历的次数不会超过一次：</p><p>从根节点出发，沿着右子节点直线向下的路径上的右连线未被遍历，其余的右连线都恰好遍历了一次。</p><img src="morris_explain.png"><p>鉴于含有n个节点的二叉树有n-1条边，因此该过程的时间复杂度为O(n)。</p><p class="note note-danger">  除了根节点外，其余节点均存在父节点，且存在一条线与父节点相连，所以含有n个节点的二叉树有n-1条边。</p></li></ol><p>因此，整个算法的时间复杂度为O(n)，其中n是树中节点的总数。</p><h2 id="5-三种方案优缺点分析"><a href="#5-三种方案优缺点分析" class="headerlink" title="5 三种方案优缺点分析"></a><span class="label label-info">5 三种方案优缺点分析</span></h2><p>这三种二叉树中序遍历的方案各有其优缺点，主要体现在空间复杂度、时间复杂度以及算法的复杂性上。下面是对这三种方案的优缺点对比：</p><h3 id="方案一：递归（Recursion）"><a href="#方案一：递归（Recursion）" class="headerlink" title="方案一：递归（Recursion）"></a><span class="label label-info">方案一：递归（Recursion）</span></h3><p><strong>优点</strong>:</p><ul><li><strong>简洁易懂</strong>：递归方案的代码简洁，逻辑清晰，易于理解和实现。</li><li><strong>自然的遍历方式</strong>：递归利用了函数调用栈，自然地实现了深度优先搜索（DFS），包括中序遍历。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>空间复杂度</strong>：在最坏情况下（树完全不平衡时），递归栈的深度可以达到O(n)，导致高空间复杂度。</li><li><strong>栈溢出风险</strong>：深度很大的树可能导致调用栈溢出。</li></ul><h3 id="方案二：基于栈的迭代（Stack-based-Iteration）"><a href="#方案二：基于栈的迭代（Stack-based-Iteration）" class="headerlink" title="方案二：基于栈的迭代（Stack-based Iteration）"></a><span class="label label-info">方案二：基于栈的迭代（Stack-based Iteration）</span></h3><p><strong>优点</strong>:</p><ul><li><strong>避免递归的栈溢出</strong>：使用显式栈代替递归调用的隐式栈，可以避免深度很大的树造成的栈溢出问题。</li><li><strong>空间复杂度可控</strong>：空间复杂度主要取决于树的高度，最坏情况下为O(h)，h为树的高度，一般情况下比递归方法的空间复杂度要好。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>实现复杂性</strong>：相比递归方案，迭代方案在实现上更为复杂，代码可读性和可维护性略有下降。</li></ul><h3 id="方案三：Morris-Traversal"><a href="#方案三：Morris-Traversal" class="headerlink" title="方案三：Morris Traversal"></a><span class="label label-info">方案三：Morris Traversal</span></h3><p><strong>优点</strong>:</p><ul><li><strong>空间复杂度低</strong>：Morris遍历的最大优点是空间复杂度为O(1)，不需要额外空间进行节点的存储。</li><li><strong>原地遍历</strong>：通过修改树的结构（临时改变指针）来避免使用栈，遍历完成后恢复树的原状。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>复杂性高</strong>：Morris遍历算法的逻辑相比前两种方法复杂，对树的结构进行了临时修改，需要仔细处理以避免错误，对于初学者来说可能不太容易理解。</li><li><strong>修改树结构</strong>：虽然最终恢复了树的原状，但算法执行过程中对树的结构进行了临时的修改，这在某些情况下可能是不可接受的。</li></ul><p><strong>总结</strong>：</p><ul><li>如果栈溢出是一个问题，或者树的深度非常大，推荐使用基于栈的迭代方案。</li><li>如果对空间复杂度有严格要求，可以考虑Morris遍历。</li><li>对于大多数简单应用，递归方法因其简洁性而更受欢迎。</li></ul><h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6 引用"></a><span class="label label-default">6 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树的后序遍历</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://hwxll.github.io/2024/02/05/kmp/">字符串匹配之 KMP 算法</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
      <category>Tree</category>
      
      <category>Binary Tree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配之 KMP 算法</title>
    <link href="/2024/02/05/kmp/"/>
    <url>/2024/02/05/kmp/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)">[1]</span></a></sup></span></h2><p>给你两个字符串 <span class="label label-danger">text</span> 和 <span class="label label-primary">pattern</span> ，请你在 <span class="label label-danger">text</span> 字符串中找出 <span class="label label-primary">pattern</span> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <span class="label label-primary">pattern</span> 不是 <span class="label label-danger">text</span> 的一部分，则返回  -1 。</p><p>其中 <code>1 &lt;= pattern.length, text.length &lt;= 10^4</code> 。</p><h2 id="2-Solution-Brute-Force-Search"><a href="#2-Solution-Brute-Force-Search" class="headerlink" title="2 Solution: Brute Force Search"></a><span class="label label-success">2 Solution: Brute Force Search</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_search</span>(<span class="hljs-params">text, pattern</span>):<br>    text_len = <span class="hljs-built_in">len</span>(text)<br>    pattern_len = <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(text_len - pattern_len + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">match</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pattern_len):<br>            <span class="hljs-keyword">if</span> text[i + j] != pattern[j]:<br>                <span class="hljs-keyword">match</span> = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>该朴素算法（brute-force）字符串搜索的时间复杂度为 <code>O((n - m + 1) * m)</code> ，其中 <code>n</code> 是文本的长度，<code>m</code> 是 <span class="label label-primary">pattern</span> 的长度。</p><p>具体分析如下：</p><ol><li>外层循环从 <code>i = 0</code> 到 <code>i = n - m</code> ，总共 <code>(n - m + 1)</code> 次迭代。</li><li>对于外层循环的每次迭代，内层循环运行 <code>m</code> 次，其中m是 <span class="label label-primary">pattern</span> 的长度。</li><li>在内层循环中，对于 <span class="label label-primary">pattern</span> 的每个字符，执行了常数时间的比较。</li></ol><p>因此，总体时间复杂度为 <code>O((n - m + 1) * m)</code> ，其中 <code>(n - m + 1)</code> 表示文本中 <span class="label label-primary">pattern</span> 可能开始的位置数量，<code>m</code> 是 <span class="label label-primary">pattern</span> 的长度。</p><p>该算法的空间复杂度为 <code>O(1)</code> ，因为它使用了常数额外空间，与输入大小无关。</p><h2 id="3-Solution-KMP-Algorithm"><a href="#3-Solution-KMP-Algorithm" class="headerlink" title="3 Solution: KMP Algorithm"></a><span class="label label-warning">3 Solution: KMP Algorithm</span></h2><h3 id="3-1-Basic-idea"><a href="#3-1-Basic-idea" class="headerlink" title="3.1 Basic idea"></a><span class="label label-warning">3.1 Basic idea</span></h3><p>当匹配过程中发生 Mismatch 时</p><img src="/2024/02/05/kmp/mismatch.png" class=""><p>Brute Force Search 算法:</p><ul><li><span class="label label-danger">text</span> 匹配位置回退到下一个起始匹配位置</li><li><span class="label label-primary">pattern</span> 匹配位置回退到0</li></ul><img src="/2024/02/05/kmp/bfsback.png" class=""><p> KMP 算法: </p><ul><li><span class="label label-danger">text</span> 的匹配位置永远不会回退</li><li><span class="label label-primary">pattern</span> 的匹配位置会根据当前 Mismatch 位置的最长严格公共前后缀（LPS）信息回退</li></ul><img src="/2024/02/05/kmp/kmpback.png" class=""><p>因此在搜索前，需要预先计算出 <span class="label label-primary">pattern</span> 每个位置处的 LPS 信息，即在各个位置 Mismatch 时，<span class="label label-primary">pattern</span> 匹配位置需要回退到哪里。</p><h3 id="3-2-LPS-具体解释"><a href="#3-2-LPS-具体解释" class="headerlink" title="3.2 LPS 具体解释"></a><span class="label label-warning">3.2 LPS 具体解释</span></h3><p>在 KMP 算法中，LPS 代表 “Longest Proper Prefix which is also Suffix” ，即最长的既是 Proper（严格）前缀又是后缀的字符串。</p><p>具体解释如下：</p><ol><li><strong>Prefix</strong>: 一个字符串的前缀是指从字符串的开头开始的任何子串，包括空字符串和字符串本身。对于字符串 <code>&quot;ABC&quot;</code> ，它的前缀字符串包括： <code>&quot;&quot;</code> , <code>&quot;A&quot;</code> , <code>&quot;AB&quot;</code> , <code>&quot;ABC&quot;</code>。</li><li><strong>Proper Prefix</strong>: 是指一个字符串的严格前缀，即不包括字符串本身的前缀。对于字符串 <code>&quot;ABC&quot;</code> ，其proper prefix包括： <code>&quot;&quot;</code> , <code>&quot;A&quot;</code> , <code>&quot;AB&quot;</code>。</li><li><strong>Suffix</strong>: 一个字符串的后缀是指从字符串的结尾开始的任何子串，包括空字符串和字符串本身。对于字符串 <code>&quot;ABC&quot;</code> ，它的后缀包括：<code>&quot;&quot;</code> , <code>&quot;C&quot;</code> , <code>&quot;BC&quot;</code> ,  <code>&quot;ABC&quot;</code>。</li></ol><p>因此，字符串 <code>&quot;ABAB&quot;</code> 的 LPS 是 <code>&quot;AB&quot;</code>，字符串 <code>&quot;ABC&quot;</code> 的 LPS 是 <code>&quot;&quot;</code>。</p><h3 id="3-3-算法预处理：为-pattern-构建-LPS-数组"><a href="#3-3-算法预处理：为-pattern-构建-LPS-数组" class="headerlink" title="3.3 算法预处理：为 pattern 构建 LPS 数组"></a><span class="label label-warning">3.3 算法预处理：为 pattern 构建 LPS 数组</span></h3><p>LPS 数组是一个用于加速 KMP 算法的辅助数组，用于在匹配失败时跳过尽可能多的字符，从而提高字符串匹配的效率。</p><p>例如，对于 <span class="label label-primary">pattern</span> <code>&quot;abazabaxtabazabazp&quot;</code> , LPS 数组是 [0, 0, 1, 0, 1, 2, 3, 0, 0, 1, 2, 3, 4, 5, 6, 7, 4, 0]。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stylus">LPS<span class="hljs-selector-attr">[i]</span> 含义：字符串 <span class="hljs-selector-tag">pattern</span><span class="hljs-selector-attr">[:i+1]</span> 的 LPS 的长度<br><br><span class="hljs-string">&quot;a&quot;</span>: 公共严格前后缀为<span class="hljs-string">&quot;&quot;</span> 或者说 无公共严格前后缀, LPS<span class="hljs-selector-attr">[0]</span> 永远等于<span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;ab&quot;</span>: 无公共严格前后缀，LPS<span class="hljs-selector-attr">[1]</span> = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;aba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，LPS<span class="hljs-selector-attr">[2]</span> = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abaz&quot;</span>: 无公共严格前后缀，LPS<span class="hljs-selector-attr">[3]</span> = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abaza&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，LPS<span class="hljs-selector-attr">[4]</span> = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abazab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;ab&quot;</span>，LPS<span class="hljs-selector-attr">[5]</span> = <span class="hljs-number">2</span><br><br><span class="hljs-string">&quot;abazaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;aba&quot;</span>，LPS<span class="hljs-selector-attr">[6]</span> = <span class="hljs-number">3</span><br><br><span class="hljs-string">&quot;abazabax&quot;</span>: 无公共严格前后缀，LPS<span class="hljs-selector-attr">[7]</span> = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abazabaxt&quot;</span>: 无公共严格前后缀，LPS<span class="hljs-selector-attr">[8]</span> = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abazabaxta&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，LPS<span class="hljs-selector-attr">[9]</span> = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abazabaxtab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;ab&quot;</span>，LPS<span class="hljs-selector-attr">[10]</span> = <span class="hljs-number">2</span><br><br><span class="hljs-string">&quot;abazabaxtaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;aba&quot;</span>，LPS<span class="hljs-selector-attr">[11]</span> = <span class="hljs-number">3</span><br><br><span class="hljs-string">&quot;abazabaxtabaz&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abaz&quot;</span>，LPS<span class="hljs-selector-attr">[12]</span> = <span class="hljs-number">4</span><br><br><span class="hljs-string">&quot;abazabaxtabaza&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abaza&quot;</span>，LPS<span class="hljs-selector-attr">[13]</span> = <span class="hljs-number">5</span><br><br><span class="hljs-string">&quot;abazabaxtabazab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazab&quot;</span>，LPS<span class="hljs-selector-attr">[14]</span> = <span class="hljs-number">6</span><br><br><span class="hljs-string">&quot;abazabaxtabazaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazaba&quot;</span>，LPS<span class="hljs-selector-attr">[15]</span> = <span class="hljs-number">7</span><br><br><span class="hljs-string">&quot;abazabaxtabazabaz&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazabaz&quot;</span>，LPS<span class="hljs-selector-attr">[16]</span> = <span class="hljs-number">4</span><br><br><span class="hljs-string">&quot;abazabaxtabazabazp&quot;</span>: 无公共严格前后缀，LPS<span class="hljs-selector-attr">[17]</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>如何使用代码来生成 LPS 数组呢？</strong></p><p>假设我们已经计算出了 <code>&quot;abazabaxtabazab&quot;</code> 的 LPS 为 <code>&quot;abazab&quot;</code> </p><img src="/2024/02/05/kmp/lps01.png" class=""><p>如何计算 <code>&quot;abazabaxtabazaba&quot;</code> 的 LPS 呢？</p><img src="/2024/02/05/kmp/lps10.png" class=""><p>显然 <span class="label label-primary">pattern[6] &#x3D;&#x3D; pattern[15]</span></p><img src="/2024/02/05/kmp/lps1.png" class=""><p> <code>&quot;abazabaxtabazaba&quot;</code> 的 LPS 为 <code>&quot;abazaba&quot;</code></p><img src="/2024/02/05/kmp/lps2.png" class=""><p>接下来计算 <code>&quot;abazabaxtabazabaz&quot;</code> 的 LPS</p><img src="/2024/02/05/kmp/lps3.png" class=""><p>此刻 <span class="label label-primary">pattern[7] !&#x3D; pattern[16]</span></p><img src="/2024/02/05/kmp/lps4.png" class=""><p>我们需要找到一个更短的前缀进行尝试</p><img src="/2024/02/05/kmp/lps5.png" class=""><p>此刻 <span class="label label-primary">pattern[4] &#x3D;&#x3D; pattern[16]</span></p><img src="/2024/02/05/kmp/lps6.png" class=""><p> <code>&quot;abazabaxtabazabaz&quot;</code> 的 LPS 为 <code>&quot;abaz&quot;</code></p><img src="/2024/02/05/kmp/lps7.png" class=""><p>最后计算 <code>&quot;abazabaxtabazabazp&quot;</code> 的 LPS</p><img src="/2024/02/05/kmp/lps8.png" class=""><p>发现没有更短前缀可以尝试(或者说这里在匹配 <code>&quot;&quot;</code> 前缀)，并且 <span class="label label-primary">pattern[0] !&#x3D; pattern[17]</span> ，所以 LPS &#x3D; 0</p><img src="/2024/02/05/kmp/lps9.png" class=""><p>当没有前缀可以匹配(或者说在匹配 <code>&quot;&quot;</code> 前缀)时的两种情况</p><ul><li>当前匹配字符与 <span class="label label-primary">pattern[0]</span> 相等，LPS &#x3D; 1</li><li>当前匹配字符与 <span class="label label-primary">pattern[0]</span> 不相等，LPS &#x3D; 0</li></ul><img src="/2024/02/05/kmp/lps_end.png" class=""><p>实现逻辑总结：</p><ol><li><p>我们在最开始初始化一个前缀长度变量 <code>prefix = 0</code> ，表示只有单个字符的字符串没有 LPS 。</p></li><li><p>然后从 <code>i = 1</code> 开始由短到长逐渐计算每个字符串的 LPS</p><p><strong>匹配成功时的增长：</strong> 如果字符匹配成功（<span class="label label-primary">pattern[i] &#x3D;&#x3D; pattern[prefix]</span>），则继续增加前缀的长度（<code>prefix += 1</code>）。</p><p><strong>匹配失败时的回退：</strong> 当发生匹配失败时（<span class="label label-primary">pattern[i] !&#x3D; pattern[prefix]</span>），通过回退的方式，找到一个更短的前缀进行尝试。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_lps_array</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    lps = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-comment"># 初始前缀长度为0</span><br>    prefix = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 从第二个字符开始遍历pattern</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>        <span class="hljs-comment"># 匹配失败时，回退前缀长度，条件 prefix &gt; 0 保证了可回退 </span><br>        <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>            prefix = lps[prefix - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 匹配成功，增加前缀长度</span><br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[prefix]:<br>            prefix += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 匹配失败时 lps[i] = 0</span><br>        lps[i] = prefix<br>    <br>    <span class="hljs-keyword">return</span> lps<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong></p><p class="note note-info"> 初始时我觉得代码包括两层循环结构，所以时间复杂度是 O(m^2) ，其中 m 是 <span class="label label-primary">pattern</span> 的长度，但是网上都说是 O(m) 让我很难理解。</p><p>在每一轮 for 循环中，<code>prefix</code> 在匹配成功时增加1，而在匹配失败时可能经过多次回退。然而，总的回退次数受限于总的成功匹配次数，<code>prefix</code> 至多增加到 <code>m</code>，所以总的回退次数至多也是 <code>m</code>。因此，整体的时间复杂度为 <code>O(m)</code>。</p><p class="note note-success">可以这样想，我有一张初始余额为0 (prefix = 0)的银行卡，每次匹配成功，就在卡里存1块钱(prefix += 1)，每次匹配失败时，就花一次钱(prefix = lps[prefix - 1])，但是花钱的额度不能超过余额(同时是正整数元）。<br/><br/>在整个构建 lps[] 的过程中，我至多存 m 块钱，因此我至多消费 m 块钱，所以消费次数(匹配失败回退次数)一定不超过 m。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回退虽然在两层循环中进行，但是整个过程至多回退m次</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>    <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>        prefix = lps[prefix - <span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>打破了我对嵌套的两层循环，一定是平方时间复杂度的认知。下面的这个例子，时间复杂度是 <code>O(nlogn)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外层循环n次，内层循环log(n)次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j *= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 做一些操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-搜索部分"><a href="#3-4-搜索部分" class="headerlink" title="3.4 搜索部分"></a><span class="label label-warning">3.4 搜索部分</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    lps = compute_lps_array(pattern)<br>    text_index = pattern_index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">while</span> text_index &lt; <span class="hljs-built_in">len</span>(text):<br>        <span class="hljs-comment"># 如果当前字符匹配，则继续比较下一个字符</span><br>        <span class="hljs-keyword">if</span> text[text_index] == pattern[pattern_index]:<br>            text_index += <span class="hljs-number">1</span><br>            pattern_index += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 如果pattern的所有字符都匹配，则返回匹配的起始索引</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                <span class="hljs-keyword">return</span> text_index - <span class="hljs-built_in">len</span>(pattern)<br>        <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引不是0，则回退到上一个匹配字符的位置</span><br>        <span class="hljs-keyword">elif</span> pattern_index != <span class="hljs-number">0</span>:<br>            pattern_index = lps[pattern_index - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引已经是0，继续检查text的下一个字符</span><br>            text_index += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>搜索部分的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 为 <span class="label label-danger">text</span> 的长度。</p><p class="note note-danger">分析同上，<span class="label label-primary">pattern_index</span> 在匹配成功时增加1，在匹配失败时回退。然而，总的回退次数受限于总的成功匹配次数，<span class="label label-primary">pattern_index</span> 至多增加 n 次，所以总的回退次数至多也是 n。因此，整体的时间复杂度为 O(n)。</p><p>所以 KMP 算法的总体时间复杂度为 <code>O(m + n)</code>。</p><h2 id="4-效率对比"><a href="#4-效率对比" class="headerlink" title="4 效率对比"></a><span class="label label-danger">4 效率对比</span></h2><p>起因是我想知道自己实现的 KMP 算法与 Python 自带的 str.find() 方法有多大的差距。</p><p>测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_search</span>(<span class="hljs-params">text, pattern</span>):<br>    text_len = <span class="hljs-built_in">len</span>(text)<br>    pattern_len = <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(text_len - pattern_len + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">match</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pattern_len):<br>            <span class="hljs-keyword">if</span> text[i + j] != pattern[j]:<br>                <span class="hljs-keyword">match</span> = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_lps_array</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    lps = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-comment"># 初始前缀长度为0</span><br>    prefix = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 从第二个字符开始遍历pattern</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>        <span class="hljs-comment"># 匹配失败时，回退前缀长度，条件 prefix &gt; 0 保证了可回退 </span><br>        <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>            prefix = lps[prefix - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 匹配成功，增加前缀长度（包括了 prefix = 0 且 匹配成功的情况）</span><br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[prefix]:<br>            prefix += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 匹配失败时 lps[i] = 0</span><br>        lps[i] = prefix<br>    <br>    <span class="hljs-keyword">return</span> lps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    lps = compute_lps_array(pattern)<br>    text_index = pattern_index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">while</span> text_index &lt; <span class="hljs-built_in">len</span>(text):<br>        <span class="hljs-comment"># 如果当前字符匹配，则继续比较下一个字符</span><br>        <span class="hljs-keyword">if</span> text[text_index] == pattern[pattern_index]:<br>            text_index += <span class="hljs-number">1</span><br>            pattern_index += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 如果pattern的所有字符都匹配，则返回匹配的起始索引</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                <span class="hljs-keyword">return</span> text_index - <span class="hljs-built_in">len</span>(pattern)<br>        <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引不是0，则回退到上一个匹配字符的位置</span><br>        <span class="hljs-keyword">elif</span> pattern_index != <span class="hljs-number">0</span>:<br>            pattern_index = lps[pattern_index - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引已经是0，继续检查text的下一个字符</span><br>            text_index += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建文本和模式</span><br>text = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&#x27;b&#x27;</span><br>pattern = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;b&#x27;</span><br><br><span class="hljs-comment"># 测试暴力搜索算法</span><br>start = time.time()<br>res = brute_force_search(text, pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Brute Force Search:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># 测试KMP算法</span><br>start = time.time()<br>res = kmp_search(text, pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;KMP Search:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># Python find()</span><br>start = time.time()<br>res = text.find(pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Python find:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># Brute Force Search: 10057.930946350098 ms, res = 999900</span><br><span class="hljs-comment"># KMP Search: 449.2683410644531 ms, res = 999900</span><br><span class="hljs-comment"># Python find: 1.7478466033935547 ms, res = 999900</span><br></code></pre></td></tr></table></figure><p>最开始很震惊，为什么 Python str.find() 方法运行效率比我的 KMP 快这么多？</p><p class="note note-primary">Python 自带的 find 方法是用 C 语言实现的，在底层经过高度优化，因此在大多数情况下会比纯 Python 代码更快。<br/><br/>而 KMP 算法虽然在某些情况下比朴素的字符串匹配算法更高效，但是它的实现依然是纯 Python 代码。尽管 KMP 算法的时间复杂度为 O(n + m)，其中 n 为文本长度，m 为模式串长度，但是在实际情况下，算法中涉及了大量的数组操作和条件判断，这些操作在 Python 中相比 C 语言而言速度会慢一些。因此，对于较大规模的数据，Python  自带的 find 方法通常会更快，因为它是直接调用底层 C 代码执行查找操作。<br/><br/>总的来说，Python 的内置方法通常会经过高度优化，运行速度更快，但在一些特定情况下，使用自定义的算法可能会更适合。</p><p>下面使用 C 来实现 KMP 算法看一下运行效率。</p><h2 id="5-C语言版本KMP"><a href="#5-C语言版本KMP" class="headerlink" title="5 C语言版本KMP"></a><span class="label label-info">5 C语言版本KMP</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kmp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* pattern)</span> &#123;<br>    <span class="hljs-type">int</span> tlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (text[tlen] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        tlen++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> plen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pattern[plen] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        plen++;<br>    &#125;<br><br>    <span class="hljs-type">int</span>* lps = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(plen * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (lps == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 内存分配失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构建 lps 数组</span><br>    <span class="hljs-type">int</span> prefix = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; plen; i++) &#123;<br>        <span class="hljs-keyword">while</span> (prefix &gt; <span class="hljs-number">0</span> &amp;&amp; pattern[i] != pattern[prefix]) &#123;<br>            prefix = lps[prefix - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[prefix]) &#123;<br>            prefix++;<br>        &#125;<br><br>        lps[i] = prefix;<br>    &#125;<br><br>    <span class="hljs-comment">// 匹配过程</span><br>    <span class="hljs-type">int</span> pi = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ti = <span class="hljs-number">0</span>; ti &lt; tlen; ti++) &#123;<br>        <span class="hljs-keyword">while</span> (pi &gt; <span class="hljs-number">0</span> &amp;&amp; text[ti] != pattern[pi]) &#123;<br>            pi = lps[pi - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (text[ti] == pattern[pi]) &#123;<br>            <span class="hljs-keyword">if</span> (pi == plen - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">free</span>(lps);<br>                <span class="hljs-keyword">return</span> ti - plen + <span class="hljs-number">1</span>;<br>            &#125;<br>            pi++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(lps);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，用于生成由n个c字符组成的字符串</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">repeat_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-comment">// 分配n+1个字节的内存空间，用于存储字符串和结束符&#x27;\0&#x27;</span><br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 判断内存分配是否成功</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 使用memset函数，将s的前n个字节都填充为c字符</span><br>    <span class="hljs-built_in">memset</span>(s, c, n);<br>    <span class="hljs-comment">// 在最后一个字节添加结束符&#x27;\0&#x27;</span><br>    s[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// 返回生成的字符串</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span>* text = repeat_char(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1000001</span>);<br>    text[<span class="hljs-number">1000000</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-type">char</span>* pattern = repeat_char(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">101</span>);<br>    pattern[<span class="hljs-number">100</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><br>    <span class="hljs-type">clock_t</span> start_time = clock();<br>    <span class="hljs-type">int</span> result = kmp_search(text, pattern);<br>    <span class="hljs-type">clock_t</span> end_time = clock();<br>    <span class="hljs-type">double</span> execution_time = ((<span class="hljs-type">double</span>)(end_time - start_time)) / CLOCKS_PER_SEC * <span class="hljs-number">1000.0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Execution Time: %f ms\n&quot;</span>, execution_time);<br><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern found at index %d\n&quot;</span>, result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern not found in the text\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// output</span><br><span class="hljs-comment">// Execution Time: 8.270000 ms</span><br><span class="hljs-comment">// Pattern found at index 999900</span><br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">text</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-attr">pattern</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>用时对比：</p><table><thead><tr><th>Algorithm</th><th>Time (ms)</th></tr></thead><tbody><tr><td>Brute Force Search (Python)</td><td>10057.931</td></tr><tr><td>KMP Search (Python)</td><td>449.268</td></tr><tr><td>KMP Search (C)</td><td>8.270</td></tr><tr><td>Python find</td><td>1.748</td></tr></tbody></table><p>可以看出 Python 和 C 的执行效率存在巨大差距。</p><h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6 引用"></a><span class="label label-default">6 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">LeetCode 28. 找出字符串中第一个匹配项的下标</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>String</category>
      
      <category>String Matching</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 CAS</title>
    <link href="/2022/08/19/cas/"/>
    <url>/2022/08/19/cas/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java层面探究"><a href="#1-Java层面探究" class="headerlink" title="1 Java层面探究"></a><span class="label label-primary">1 Java层面探究</span></h2><p>Java中的原子类<code>Atomic</code>底层的实现原理是CAS，本文就让我们一起来深入探究CAS。<br>下面是<code>AtomicInteger</code>的测试代码 ，执行完毕后会发现原子类实例<code>ai</code>最终是精确的10000，而普通变量<code>bi</code>的值是一个小于10000的不固定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hw.review2022.concurrent;<br> <br><span class="hljs-keyword">import</span> org.junit.Test;<br> <br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCAS</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 被多个线程访问的变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对ai和bi执行1000次自增</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-comment">//任务id</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = i;<br>        &#125;<br> <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>               <span class="hljs-keyword">try</span>&#123;<br>                   <span class="hljs-keyword">if</span>(i % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) &#123;<br>                       System.out.println(<span class="hljs-string">&quot;Thread name : &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, Task id : &quot;</span> + id + <span class="hljs-string">&quot;, loop : &quot;</span> + i);<br>                   &#125;<br>                   Thread.sleep(<span class="hljs-number">2</span>);<br>                   ai.addAndGet(<span class="hljs-number">1</span>);<br>                   bi++;<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 创建含有3个线程的线程池</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在线程池中执行10个任务</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(i));<br>        &#125;<br> <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 等待线程池中的任务执行完毕后才去打印ai和bi的值</span><br><span class="hljs-comment">         */</span><br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>        System.out.println(<span class="hljs-string">&quot;ai is right : &quot;</span> + ai);<br>        System.out.println(<span class="hljs-string">&quot;bi is wrong : &quot;</span> + bi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的核心是 <code>AtomicInteger.addAndGet</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Atomically adds the given value to the current value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delta the value to add</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the updated value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addAndGet</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, delta) + delta;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们看一下<code>AtomicInteger</code>类实例对象的内存布局</p><img src="/2022/08/19/cas/layout.png" class=""><p><code>this</code>指向了对象的起始地址，通过<code>this + valueOffset(=12)</code>我们就可以获得<code>value</code>字段的内存地址（即C&#x2F;C++中的指向<code>value</code>的指针），进而读写该<code>value</code>值。</p><p>然后我们接着看<code>Unsafe.getAndAddInt</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//                             原子实例ai  valueOffset  delta(增量)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2); <span class="hljs-comment">// var5: oldValue</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4)); <span class="hljs-comment">// var5 + var4: updateValue</span><br> <br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>var5</code>这个变量是通过<code>ai</code>的起始地址 + <code>valueOffset</code>偏移值获取到<code>value</code>的内存地址，进而获取到的<code>value</code>的值，我们把这个值称为<span class="label label-primary">oldValue</span></p><p><code>var5+var4</code>就是我们期望更新的值，我们把它叫做<span class="label label-info">updateValue</span></p><p>接下来发现<code>Unsafe.compareAndSwapInt</code>是一个 native 方法(就是在Java虚拟机中用 C&#x2F;C++ 实现的方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br></code></pre></td></tr></table></figure><h2 id="2-C-C-层面探究"><a href="#2-C-C-层面探究" class="headerlink" title="2 C&#x2F;C++层面探究"></a><span class="label label-success">2 C&#x2F;C++层面探究</span></h2><p>现在Java语言层面我们已经分析完了，完全看不到CAS具体是怎么实现的，接下来我们继续去探究JDK源码<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github OpenJDK8源码](https://github.com/AdoptOpenJDK/openjdk-jdk8u)">[1]</span></a></sup></p><p><code>Unsafe.compareAndSwapInt</code>的源码所在目录为<code>hotspot/src/share/vm/prims/unsafe.cpp</code></p><p>这个方法的前两个参数不用去了解（JNI是Java调用C的方式），后四个参数和<code>Unsafe.compareAndSwapInt</code>方法的一一对应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UNSAFE_ENTRY</span>(jboolean, <span class="hljs-built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  <span class="hljs-built_in">UnsafeWrapper</span>(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  oop p = JNIHandles::<span class="hljs-built_in">resolve</span>(obj);<br>  jint* addr = (jint *) <span class="hljs-built_in">index_oop_from_field_offset_long</span>(p, offset);<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * x代表了期望更新的值updateValue</span><br><span class="hljs-comment">   * addr代表了value这个字段的内存地址</span><br><span class="hljs-comment">   * e代表了oldValue</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> (jint)(Atomic::<span class="hljs-built_in">cmpxchg</span>(x, addr, e)) == e;<br>UNSAFE_END<br></code></pre></td></tr></table></figure><p>继续往下分析来到了最核心的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> jint     <span class="hljs-title function_">Atomic::cmpxchg</span>    <span class="hljs-params">(jint     exchange_value, <span class="hljs-keyword">volatile</span> jint*     dest, jint     compare_value)</span> &#123;<br>  <span class="hljs-type">int</span> mp = os::is_MP(); <span class="hljs-comment">// MP means multiprocessor，多处理器系统需要给cmpxchg指令加上lock前缀</span><br>  __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgl %1,(%3)&quot;</span></span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)</span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)</span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>  <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cmpxchgl</code>是一个汇编指令（最后一个字符<code>l</code>代表了<code>cmpxchg</code>指令的参数类型为<code>jint</code>，对于<code>jlong</code>类型最后一个字符是<code>q</code>，不同操作系统可能会不同），所以我们需要去理解<code>cmpxchg</code>这条汇编指令。</p><h2 id="3-汇编层面探究"><a href="#3-汇编层面探究" class="headerlink" title="3 汇编层面探究"></a><span class="label label-danger">3 汇编层面探究</span></h2><p>下面给出我在C中实现的CAS来帮助大家理解CAS和<code>cmpxchg</code>指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pthread.h&quot;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_task</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被多个线程访问的共享变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-type">atomic_count</span> = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid, tid2, tid3, tid4, tid5, tid6;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建了6个子线程，tid为子线程id，task和atomic_task是子线程的任务函数</span><br><span class="hljs-comment">     */</span><br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid4, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid5, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid6, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程等待6个子线程执行完才会往下执行printf</span><br><span class="hljs-comment">     */</span><br>    pthread_join(tid, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid4, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid5, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid6, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count); <span class="hljs-comment">//预期最后的结果小于900000</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;atomic_count is %d\n&quot;</span>, <span class="hljs-type">atomic_count</span>); <span class="hljs-comment">//预期最后的结果精确等于900000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>   <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param oldValue 最开始获取到的value值</span><br><span class="hljs-comment"> * @param addr 多线程访问的变量的地址</span><br><span class="hljs-comment"> * @param updateValue 期望更新的新值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span> &#123;<br>    <span class="hljs-type">int</span> resValue;<br>    __asm__ __volatile__ (<span class="hljs-string">&quot;lock\n\t&quot;</span><br>                          <span class="hljs-string">&quot;cmpxchgl %2, (%3)&quot;</span><br>                          : <span class="hljs-string">&quot;=a&quot;</span>(resValue)<br>                          : <span class="hljs-string">&quot;a&quot;</span>(oldValue), <span class="hljs-string">&quot;r&quot;</span>(updateValue), <span class="hljs-string">&quot;r&quot;</span>(addr)<br>                          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>);<br>    <span class="hljs-keyword">return</span> resValue;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param addr 多线程访问变量的地址</span><br><span class="hljs-comment"> * @param delta 这个变量想要增加的值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> oldValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = *addr;<br>    &#125; <span class="hljs-keyword">while</span> ( cmp(oldValue, addr, oldValue + delta) != oldValue );<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300000</span>; i++) &#123;<br>        <span class="hljs-type">atomic_add</span>(&amp;<span class="hljs-type">atomic_count</span>, <span class="hljs-number">1</span>);<br>        usleep(<span class="hljs-number">60</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300000</span>; i++) &#123;<br>        count += <span class="hljs-number">1</span>;<br>        usleep(<span class="hljs-number">60</span>); <span class="hljs-comment">//0.06ms</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点讲解一下<code>cmp</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span> &#123;<br>    <span class="hljs-type">int</span> resValue;<br>    __asm__ __volatile__ (<span class="hljs-string">&quot;lock\n\t&quot;</span>   <span class="hljs-comment">//保证原子性</span><br>                          <span class="hljs-string">&quot;cmpxchgl %2, (%3)&quot;</span> <span class="hljs-comment">//核心指令</span><br>                          : <span class="hljs-string">&quot;=a&quot;</span>(resValue) <span class="hljs-comment">//输出列表</span><br>                          : <span class="hljs-string">&quot;a&quot;</span>(oldValue), <span class="hljs-string">&quot;r&quot;</span>(updateValue), <span class="hljs-string">&quot;r&quot;</span>(addr) <span class="hljs-comment">//输入列表</span><br>                          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>); <span class="hljs-comment">//表明这条内联汇编会更改内存值和flag寄存器</span><br>    <span class="hljs-keyword">return</span> resValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实也就是我自己实现的JDK中的<code>Atomic::cmpxchg</code>函数，只不过更容易看懂一些。</p><p><span class="label label-primary">oldValue</span>就是我们先前获取到的<code>value</code>值，<code>addr</code>就是<code>value</code>字段的内存地址，在<code>cmpxchg</code>指令中会用到这个地址，<span class="label label-info">updateValue</span>就是我们期望更新的<code>value</code>值(<span class="label label-primary">oldValue</span>+增量<code>delta</code>)</p><p>以下关于内联汇编的知识大家可以去参考GCC-Inline-Assembly-HOWTO<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[GCC-Inline-Assembly-HOWTO](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)">[2]</span></a></sup></p><p>输入列表中：</p><p><code>&quot;a&quot;(oldValue)</code>：a代表EAX寄存器，意思是将变量<span class="label label-primary">oldValue</span>的值输入到EAX寄存器</p><p><code>&quot;r&quot;(updateValue) &quot;r&quot;(addr)</code>：意思是将变量<span class="label label-info">updateValue</span>和地址<code>addr</code>也放到寄存器中，r(register)代表一组寄存器，也就是从这一组寄存器中随便选一个存<span class="label label-info">updateValue</span>，随便选一个存<code>addr</code></p><p>输出列表中：</p><p><code>&quot;=a&quot;(resValue)</code>：表示内联汇编执行完后，将EAX寄存器的值存到<code>resValue</code>这个变量中。</p><p>我们在输出列表和输入列表中声明了许多变量，这些变量从<code>%0</code>开始依次往下标号，所以<code>%0</code>表示<code>resValue</code>，<code>%1</code>代表了<span class="label label-primary">oldValue</span>，<code>%2</code>代表了<span class="label label-info">updateValue</span>，<code>%3</code>代表了<code>addr</code>。</p><p>现在我们结合的<code>cmpxchg</code>指令的功能，来理解一下这段汇编到底在做什么。汇编语言有Intel和AT&amp;T两种语法，一般我们用的都是AT&amp;T这种，下面的讲解也是基于该语法的:</p><p class="note note-info">cmpxchg 指令有两个操作数，同时还使用了EAX 寄存器。首先，它将第二个操作数和EAX寄存器相比较，如果相同则把第一个操作数赋值给第二个操作数，否则将第一个操作数赋值给EAX 寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmpxchgl %2, (%3) <br></code></pre></td></tr></table></figure><p><code>%2</code>是第一个操作数，即<span class="label label-info">updateValue</span>，也就是无冲突的时候我们期望更新的值</p><p><code>(%3)</code>是第二个操作数，即<code>(addr)</code>，<code>()</code>表示取值操作(相当于C语言中的<code>*</code>)，因为<code>addr</code>是<code>value</code>变量的地址，所以该操作数是在取此刻<code>value</code>的值<code>curValue</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *a = <span class="hljs-number">5</span>; <span class="hljs-comment">//代表了a是一个指针，指向一个int变量，即a是该int变量的地址，*a表示取该int变量的值5</span><br></code></pre></td></tr></table></figure><p>首先将<span class="label label-primary">oldValue</span>存储到EAX寄存器中，然后用第二个操作数<code>curValue</code>和<span class="label label-primary">oldValue</span>行比较，如果相等，则说明从得到<span class="label label-primary">oldValue</span>到现在执行<code>cmpxchg</code>这条指令这段时间内，<code>value</code>没有被其他线程改写（抛开ABA问题不谈），没有发生冲突，所以我们就可以直接把我们希望更新的新值<span class="label label-info">updateValue</span>写入到<code>value</code>中，那我们再来看看<code>cmpxchg</code>这条指令干了啥，如果相同则把第一个操作数赋值给第二个操作数，也就是将<span class="label label-info">updateValue</span>赋值给<code>value</code>对象（成功更新<code>value</code>的值）。现在这条指令就执行完毕了，EAX寄存器中存储的还是<span class="label label-primary">oldValue</span>，所以最终<code>cmp</code>函数返回的也就是<span class="label label-primary">oldValue</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> oldValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = *addr;<br>    &#125; <span class="hljs-keyword">while</span> ( cmp(oldValue, addr, oldValue + delta) != oldValue );<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数也就可以返回了，对应的就是Java中的<code>Unsafe.getAndAddInt</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br> <br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果EAX中保存的<span class="label label-primary">oldValue</span>和我们执行<code>cmpxchg</code>指令时获取的<code>curValue</code>不同，说明<code>value</code>的值被其他线程改写了，那此刻将第一个操作数<span class="label label-info">updateValue</span>赋值给 EAX 寄存器（我们并没有更新<code>value</code>的值），所以<code>cmp</code>函数返回的值为<span class="label label-info">updateValue</span>。<code>atomic_add</code>函数中<code>cmp</code>返回的<span class="label label-info">updateValue</span>和<span class="label label-primary">oldValue</span>不同，所以要重新执行<code>do while</code>循环去自旋，直到没有冲突发生。</p><h2 id="4-动画展示与总结"><a href="#4-动画展示与总结" class="headerlink" title="4 动画展示与总结"></a><span class="label label-info">4 动画展示与总结</span></h2><p>该动画使用Python <code>manim</code>库<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github 3b1b/manim](https://github.com/3b1b/manim)">[3]</span></a></sup>制作，<a href="https://github.com/hwollin/animation/blob/main/os/thread/concurrent/cas_animation.py">动画源码</a></p><video width="100%" controls>  <source src="cas.mp4" type="video/mp4"></video><p>最后我们再用高级语言解释一下<code>cmpxchg</code>这条汇编指令的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被多个线程访问的value对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> value;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意下面的逻辑是一条汇编指令完成的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param addr value对象的内存地址</span><br><span class="hljs-comment"> * @param oldValue 执行cmpxchg指令前当前线程获取到的value对象的值</span><br><span class="hljs-comment"> * @param updateValue 期望更新的值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmpxchg</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span> updateValue)</span><br>&#123;<br>    <span class="hljs-type">int</span> curValue = *addr; <span class="hljs-comment">//获取最新的value的值</span><br>    <span class="hljs-keyword">if</span> (curValue == oldValue) &#123; <span class="hljs-comment">//无冲突则更新value值为updateValue并返回oldValue</span><br>        *addr == updateValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//发生冲突，直接返回updateValue，value对象的值没有更新哦</span><br>        <span class="hljs-keyword">return</span> updateValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5 引用"></a><span class="label label-warning">5 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/AdoptOpenJDK/openjdk-jdk8u">Github OpenJDK8源码</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/3b1b/manim">Github 3b1b&#x2F;manim</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Concurrency Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>C/C++</tag>
      
      <tag>Assembly</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
